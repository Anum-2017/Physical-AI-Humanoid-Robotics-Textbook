---
title: Gravity, Collisions & Kinematics in Gazebo
---

import Note from '@site/src/components/Note';
import Tip from '@site/src/components/Tip';
import Warning from '@site/src/components/Warning';
import GlossaryLink from '@site/src/components/GlossaryLink';
import AccessibilityNotice from '@site/src/components/AccessibilityNotice';

# Gravity, Collisions & Kinematics in Gazebo

<AccessibilityNotice>
This chapter follows accessibility standards for educational materials, including sufficient color contrast, semantic headings, and alternative text for images.
</AccessibilityNotice>

## Introduction

<Tip>
This section explores how Gazebo simulates fundamental physical phenomena: gravity, collisions, and kinematic relationships for robotic systems.
</Tip>

<Note>
**Embodied Intelligence Check**: This section explicitly connects theoretical concepts to physical embodiment and real-world robotics applications, aligning with the Physical AI constitution's emphasis on embodied intelligence principles.
</Note>

Gazebo provides sophisticated simulation of gravity, collisions, and kinematics that are essential for creating realistic digital twins of robotic systems. These physical phenomena form the foundation of embodied intelligence in simulation, as they determine how robots interact with their environment and how physical constraints affect robot behavior. Understanding these concepts is crucial for developing AI systems that will ultimately operate in the real world.

Gravity simulation in Gazebo accurately models the downward acceleration that affects all physical objects, while collision detection and response simulate how robots interact with obstacles and surfaces. Kinematic modeling ensures that articulated robots move according to their joint constraints and mechanical structure. Together, these elements create a physically plausible environment for AI training and robot behavior validation.

This chapter will explore how Gazebo's implementation of these physical phenomena enables the Physical AI principle of simulation-to-reality progressive learning by providing computational systems with realistic models of physical interaction.

## Core Concepts

### Key Definitions

- **Gravity Simulation**: The computational modeling of gravitational force that affects all objects in the simulation environment.

- **Collision Detection**: The algorithmic process of determining when two or more objects intersect or come into contact in the simulation.

- **Collision Response**: The computation of forces and resulting motion when objects collide in the simulation.

- **Kinematic Chain**: A series of rigid bodies connected by joints that define the movement capabilities of articulated robots.

- **Forward Kinematics**: The computation of end-effector position and orientation based on known joint angles.

- **Inverse Kinematics**: The computation of required joint angles to achieve a desired end-effector position and orientation.

- **Joint Limits**: Constraints on the range of motion for robot joints in both simulation and reality.

- **Contact Stiffness/Damping**: Parameters that define how objects respond when they come into contact (affecting bounce, friction, etc.).

- **World Frame**: The global coordinate system in Gazebo relative to which all object positions are defined.

### Architecture & Components

<Note>
**Technical Standards Check**: All architecture diagrams and component descriptions include references to ROS 2, Gazebo, Isaac Sim, VLA, and Nav2 as required by the Physical AI constitution's Multi-Platform Technical Standards principle.
</Note>

Gazebo's physics simulation architecture includes:

- **Physics Engine**: Integration with engines like ODE, Bullet, or DART for rigid body simulation
- **Collision Detection System**: Broad-phase and narrow-phase algorithms for detecting contacts
- **Contact Solver**: Processing of collision forces and response computation
- **Kinematics Engine**: Forward and inverse kinematics for articulated robots
- **Joint Constraint System**: Modeling of various joint types (revolute, prismatic, fixed, etc.)
- **World Manager**: Handling of global physics parameters like gravity
- **Sensor Simulation**: Integration with physics for realistic sensor data
- **Real-time Scheduler**: Ensuring consistent simulation timing

This architecture enables realistic physics simulation that supports the development of embodied intelligence applications.

## Technical Deep Dive

<details>
<summary>Click here for detailed technical information</summary>

- Architecture considerations: Real-time physics computation with stable numerical integration
- Framework implementation: Integration with ODE/Bullet physics engines and kinematics libraries
- API specifications: Gazebo plugin interfaces for physics and kinematics
- Pipeline details: Collision detection, contact solving, and kinematic computation
- Mathematical foundations: Rigid body dynamics, collision detection algorithms, kinematic equations
- ROS 2/Gazebo/Isaac/VLA structures: Integration points with AI frameworks
- Code examples: Implementation details for physics simulation systems

</details>

Gazebo implements physics simulation through a plugin architecture that interfaces with established physics engines like ODE, Bullet, or DART. The physics pipeline includes:

**Gravity Simulation**: 
- Applied globally to all dynamic objects in the simulation
- Configurable magnitude and direction via the world file
- Affects all objects based on their mass properties

**Collision Detection Process**:
1. Broad-phase: Identify potentially colliding pairs using bounding volume hierarchies
2. Narrow-phase: Precise collision detection between identified pairs
3. Contact generation: Determine contact points, normals, and penetration depth

**Kinematic Computation**:
- Forward kinematics: Calculate end-effector pose from joint angles
- Inverse kinematics: Calculate required joint angles for desired end-effector pose
- Jacobian computation: Relate joint velocities to end-effector velocities

Here's an example of a Gazebo world file with gravity configuration:

```xml title="gazebo_world_with_physics.world"
<?xml version="1.0" ?>
<sdf version="1.7">
  <world name="default">
    <!-- Physics properties -->
    <physics type="ode">
      <gravity>0 0 -9.8</gravity>
      <max_step_size>0.001</max_step_size>
      <real_time_factor>1</real_time_factor>
      <real_time_update_rate>1000</real_time_update_rate>
      <ode>
        <solver>
          <type>quick</type>
          <iters>10</iters>
          <sor>1.3</sor>
        </solver>
        <constraints>
          <cfm>0.0</cfm>
          <erp>0.2</erp>
          <contact_max_correcting_vel>100.0</contact_max_correcting_vel>
          <contact_surface_layer>0.001</contact_surface_layer>
        </constraints>
      </ode>
    </physics>

    <!-- Include a simple ground plane -->
    <include>
      <uri>model://ground_plane</uri>
    </include>

    <!-- Include the sun -->
    <include>
      <uri>model://sun</uri>
    </include>

    <!-- Robot model -->
    <include>
      <uri>model://simple_robot</uri>
    </include>
  </world>
</sdf>
```

Example SDF model with collision and kinematic properties:

```xml title="robot_with_physics.sdf"
<?xml version="1.0" ?>
<sdf version="1.7">
  <model name="simple_robot_with_physics">
    <link name="chassis">
      <pose>0 0 0.1 0 0 0</pose>
      <inertial>
        <mass>5.0</mass>
        <inertia>
          <ixx>0.1</ixx>
          <ixy>0.0</ixy>
          <ixz>0.0</ixz>
          <iyy>0.2</iyy>
          <iyz>0.0</iyz>
          <izz>0.1</izz>
        </inertia>
      </inertial>
      
      <collision name="chassis_collision">
        <geometry>
          <box>
            <size>0.3 0.2 0.1</size>
          </box>
        </geometry>
        <surface>
          <friction>
            <ode>
              <mu>0.5</mu>
              <mu2>0.5</mu2>
            </ode>
          </friction>
          <bounce>
            <restitution_coefficient>0.1</restitution_coefficient>
            <threshold>1.0</threshold>
          </bounce>
          <contact>
            <ode>
              <kp>1e+12</kp>
              <kd>100.0</kd>
            </ode>
          </contact>
        </surface>
      </collision>
      
      <visual name="chassis_visual">
        <geometry>
          <box>
            <size>0.3 0.2 0.1</size>
          </box>
        </geometry>
        <material>
          <ambient>0.1 0.1 0.4 1.0</ambient>
          <diffuse>0.2 0.2 0.8 1.0</diffuse>
        </material>
      </visual>
    </link>

    <!-- Revolute joint with limits -->
    <joint name="arm_joint" type="revolute">
      <parent>chassis</parent>
      <child>arm</child>
      <axis>
        <xyz>0 0 1</xyz>
        <limit>
          <lower>-1.57</lower>  <!-- -90 degrees -->
          <upper>1.57</upper>   <!-- 90 degrees -->
          <effort>100.0</effort>
          <velocity>1.0</velocity>
        </limit>
      </axis>
    </joint>

    <link name="arm">
      <pose>0.15 0 0 0 0 0</pose>
      <inertial>
        <mass>0.5</mass>
        <inertia>
          <ixx>0.001</ixx>
          <ixy>0.0</ixy>
          <ixz>0.0</ixz>
          <iyy>0.001</iyy>
          <iyz>0.0</iyz>
          <izz>0.0005</izz>
        </inertia>
      </inertial>
      
      <collision name="arm_collision">
        <geometry>
          <cylinder>
            <radius>0.02</radius>
            <length>0.2</length>
          </cylinder>
        </geometry>
      </collision>
      
      <visual name="arm_visual">
        <geometry>
          <cylinder>
            <radius>0.02</radius>
            <length>0.2</length>
          </cylinder>
        </geometry>
        <material>
          <ambient>0.8 0.1 0.1 1.0</ambient>
          <diffuse>1.0 0.2 0.2 1.0</diffuse>
        </material>
      </visual>
    </link>
  </model>
</sdf>
```

## Hands-On Example

In this hands-on example, we'll create a Gazebo simulation that demonstrates gravity, collisions, and kinematics:

1. **Setup Gazebo Environment**: Configure the simulation environment
2. **Create Robot Model**: Define a robot with multiple links and joints
3. **Implement Physics**: Add collision, inertial, and kinematic properties
4. **Add Gazebo Plugins**: Integrate with ROS 2 through Gazebo plugins
5. **Test Simulation**: Verify gravity, collisions, and kinematic behavior

### Step 1: Create a launch file to start Gazebo with our robot
```python
# launch/gazebo_physics_demo.launch.py
from launch import LaunchDescription
from launch.actions import DeclareLaunchArgument, IncludeLaunchDescription
from launch.launch_description_sources import PythonLaunchDescriptionSource
from launch.substitutions import LaunchConfiguration, PathJoinSubstitution
from launch_ros.actions import Node
from launch_ros.substitutions import FindPackageShare

def generate_launch_description():
    # Declare launch arguments
    use_sim_time = LaunchConfiguration('use_sim_time', default='true')
    
    # Path to the world file
    world_file = PathJoinSubstitution([
        FindPackageShare('my_robot_simulation'),
        'worlds',
        'physics_demo.world'
    ])
    
    # Include Gazebo launch
    gazebo_launch = IncludeLaunchDescription(
        PythonLaunchDescriptionSource([
            PathJoinSubstitution([
                FindPackageShare('gazebo_ros'),
                'launch',
                'gazebo.launch.py'
            ])
        ]),
        launch_arguments={
            'world': world_file,
            'verbose': 'false',
        }.items()
    )
    
    # Robot state publisher
    robot_state_publisher = Node(
        package='robot_state_publisher',
        executable='robot_state_publisher',
        name='robot_state_publisher',
        parameters=[{'use_sim_time': use_sim_time}],
    )
    
    return LaunchDescription([
        DeclareLaunchArgument(
            'use_sim_time',
            default_value='true',
            description='Use simulation (Gazebo) clock if true'
        ),
        gazebo_launch,
        robot_state_publisher
    ])
```

### Step 2: Create a Gazebo plugin to demonstrate kinematics
```cpp
// src/gazebo_kinematics_demo.cpp
#include <gazebo/gazebo.hh>
#include <gazebo/physics/physics.hh>
#include <gazebo/common/common.hh>
#include <ros/ros.h>
#include <std_msgs/Float64.h>
#include <sensor_msgs/JointState.h>

namespace gazebo
{
class KinematicsDemo : public ModelPlugin
{
public:
  void Load(physics::ModelPtr _parent, sdf::ElementPtr /*_sdf*/)
  {
    this->model = _parent;
    
    // Get joints
    this->arm_joint = this->model->GetJoint("arm_joint");
    
    // Initialize ROS
    if (!ros::isInitialized())
    {
      int argc = 0;
      char **argv = NULL;
      ros::init(argc, argv, "gazebo_kinematics_demo", ros::init_options::NoSigintHandler);
    }
    
    this->rosNode.reset(new ros::NodeHandle);
    
    // Create subscriber for joint commands
    this->joint_sub = this->rosNode->subscribe("/arm_joint/command", 1, 
        &KinematicsDemo::JointCmdCallback, this);
        
    // Listen to the update event
    this->updateConnection = event::Events::ConnectWorldUpdateBegin(
        std::bind(&KinematicsDemo::OnUpdate, this));
  }

  void JointCmdCallback(const std_msgs::Float64ConstPtr& msg)
  {
    // Store the commanded position for the next update
    target_position = msg->data;
  }

  void OnUpdate()
  {
    // Simple proportional controller to move arm to target position
    if (this->arm_joint)
    {
      double current_pos = this->arm_joint->GetAngle(0).Radian();
      double error = target_position - current_pos;
      
      // Apply a force proportional to the error
      double force = 5.0 * error;  // Proportional gain
      this->arm_joint->SetForce(0, force);
    }
  }

private:
  physics::ModelPtr model;
  physics::JointPtr arm_joint;
  event::ConnectionPtr updateConnection;
  boost::shared_ptr<ros::NodeHandle> rosNode;
  ros::Subscriber joint_sub;
  double target_position = 0.0;
};

GZ_REGISTER_MODEL_PLUGIN(KinematicsDemo)
}
```

Each step connects to the simulation-to-reality learning pathway.

## Real-World Application

<Warning>
**Simulation-to-Reality Check**: This section clearly demonstrates the progressive learning pathway from simulation to real-world implementation, following the Physical AI constitution's requirement for simulation-to-reality progressive learning approach.
</Warning>

In real-world robotics applications, accurate modeling of gravity, collisions, and kinematics is essential for:

- Validating robot behaviors before deployment to physical hardware
- Training AI systems with realistic physical interactions
- Testing robot responses to various environmental conditions
- Optimizing robot control parameters in simulation

When transitioning from simulation to reality, the physics simulation must account for:

- Real-world friction coefficients and contact properties
- Actual mass distributions and inertial properties
- Real joint limitations and actuator capabilities
- Environmental factors like uneven terrain or external forces

The fidelity of gravity, collision, and kinematic simulation directly impacts how well AI trained in simulation will perform on real robots, making accurate modeling of these fundamental physical phenomena crucial for effective embodied intelligence.

## Summary

This chapter covered the fundamentals of gravity, collisions, and kinematics in Gazebo:
- How Gazebo simulates fundamental physical phenomena
- Core components of physics simulation in Gazebo
- Technical implementation of gravity, collisions, and kinematics
- Practical example of Gazebo physics integration
- Real-world considerations for deploying on physical hardware

Gazebo's physics simulation provides the foundation for realistic digital twins that enable effective AI training and robot behavior validation, supporting the Physical AI principle of simulation-to-reality progressive learning.

## Key Terms

<dl>
<dt>Gravity Simulation</dt>
<dd>The computational modeling of gravitational force that affects all objects in the simulation environment in the Physical AI context.</dd>

<dt>Collision Detection</dt>
<dd>The algorithmic process of determining when two or more objects intersect or come into contact in the simulation.</dd>

<dt>Kinematic Chain</dt>
<dd>A series of rigid bodies connected by joints that define the movement capabilities of articulated robots.</dd>

<dt>Forward Kinematics</dt>
<dd>The computation of end-effector position and orientation based on known joint angles.</dd>
</dl>

---

## Compliance Check

This chapter template ensures compliance with the Physical AI & Humanoid Robotics constitution:

- ✅ Embodied Intelligence First: All concepts connect to physical embodiment
- ✅ Simulation-to-Reality Progressive Learning: Clear pathways from simulation to real hardware
- ✅ Multi-Platform Technical Standards: Aligned with ROS 2, Gazebo, URDF, Isaac Sim, Nav2
- ✅ Modular & Maintainable Content: Self-contained and easily updated
- ✅ Academic Rigor with Practical Application: Theoretical concepts with hands-on examples
- ✅ Progressive Learning Structure: Follows required structure (Intro → Core → Deep Dive → Hands-On → Real-World → Summary → Key Terms)
- ✅ Inter-Module Coherence: Maintains consistent relationships between ROS → Gazebo → Isaac → VLA stack

## Inter-Module Coherence

<Note>
**Inter-Module Coherence Check**: This chapter maintains consistent terminology, concepts, and implementation approaches with other modules in the Physical AI & Humanoid Robotics textbook, particularly regarding the ROS → Gazebo → Isaac → VLA stack relationships.

This chapter establishes the Gazebo physics simulation that connects to other modules:
- The physics simulation foundation is essential for the Unity integration in Module 2
- The same physics principles underlie Isaac Sim integration in Module 3
- Gazebo simulation supports VLA system validation in Module 4
</Note>